#X3D V3.2 utf8
PROFILE Interchange

# ----------------------------------------------------------------------------
# Water surface

DEF WaterTransform Transform
{
  translation -50 0 -41
  scale 100 60 80

  children Shape
  {
    appearance Appearance
    {
      material PhysicalMaterial
      {
        transparency 0.05
        baseColor 0.9 0.9 1.0
        baseTexture RenderedTexture
        {
          dimensions [ 2048 2048 3 ]
          viewpoint ViewpointMirror { }
          repeatS FALSE
          repeatT FALSE
          update "ALWAYS"
        }
        baseTextureMapping "BASE"

        emissiveColor 1.0 1.0 1.0
        emissiveTexture MovieTexture
        {
          url "electricity/electricity@counter(4).png"
          loop TRUE
          speed 0.15
        }
        emissiveTextureMapping "ELECTRIC"

        metallic 0.8
        roughness 0.1
      }

      # Calculate animated normal vectors using GLSL
      effects DEF EffectAnimatedNormals Effect
      {
        # enabled FALSE
        language "GLSL"
        inputOnly SFTime time
        parts
        [
          EffectPart
          {
            type "VERTEX"
            url "shaders/animate_normals.vs"
          }
          EffectPart
          {
            type "FRAGMENT"
            url "shaders/animate_normals.fs"
          }
          EffectPart
          {
            type "FRAGMENT"
            url "shaders/noise3Dgrad.glsl"
          }
        ]
      }
    }
    geometry IndexedFaceSet
    {
      coord Coordinate
      {
        point [ 0 0 0, 0 0 1, 1 0 1, 1 0 0, ]
      }
      coordIndex [ 0 1 2 3 ]
      texCoord MultiGeneratedTextureCoordinate
      {
        texCoord
        [
          # generate texture coordinates
          # that match the texture produced by RenderedTexture and ViewpointMirror
          # (in diffuseTexture)
          TextureCoordinateGenerator
          {
            mode "MIRROR-PLANE"
            mapping "BASE"
          }
          # This is useful to make waves smaller/larger.
          TextureCoordinate
          {
            point [ 0 0, 0 8, 10 8, 10 0, ]
            mapping "ELECTRIC"
          }
        ]
      }
    }
  }
}


# MyTimeSensor provides values for GLSL "time" uniform.
DEF MyTimeSensor TimeSensor
{
  loop TRUE
}
ROUTE MyTimeSensor.elapsedTime TO EffectAnimatedNormals.time

# Without MyProximitySensor, MyTimeSensor.elapsedTime output
# values would be huge, as TimeSensor "starts" at Unix epoch.
# Such huge floats would make GLSL shader computations useless (the results
# of the shaders would look still).
# So we we use MyProximitySensor to activate MyTimeSensor on scene enter.
DEF MyProximitySensor ProximitySensor
{
  size 10000000 10000000 10000000 # huge size, to always be activated
}
ROUTE MyProximitySensor.enterTime TO MyTimeSensor.startTime
